from __future__ import annotations
import json, os, random
from dataclasses import dataclass, asdict, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Callable, Optional, Dict, Any, List

# ---------- enums ----------
class Level(str, Enum):
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"

class Phase(str, Enum):
    HOST_INITIATION = "HOST_INITIATION"
    INITIALIZE = "INITIALIZE"
    ITERATION = "ITERATION"
    SEPARATION = "SEPARATION"
    UNION = "UNION"
    CRYSTALLIZATION = "CRYSTALLIZATION"

# ---------- logs ----------
@dataclass
class LogEntry:
    timestamp: str
    host: str
    level: Level
    message: str
    phase: Optional[Phase] = None
    data: Dict[str, Any] = field(default_factory=dict)

# ---------- default blueprint (fallback) ----------
DEFAULT_BLUEPRINT = {
    "algorithmName": "ontological_recursion_protocol",
    "version": "2.0",
    "description": "Recursive synthesis of origin, action, mastery; crystallizes as domain sovereignty.",
    "originStory": "Discovered via autosuggest anomaly on 2025-08-23 during Obsidian Moon reset.",
    "coreFormula": {
        "syntax": "(a ⊕ b ⊕ c)ᵠ",
        "mapping": {
            "a": "origin (𒁃)",
            "b": "action (𒀱)",
            "c": "lord (𒈙)",
            "⊕": "Ternary Synthesis (exclusive reconciliation)",
            "ᵠ": "Recursive Integration (iterative return)"
        }
    },
    "keyConcepts": {
        "origin": {"symbol": "𒁃", "meaning": "Foundational Truth Anchor"},
        "action": {"symbol": "𒀱", "meaning": "Operational Process"},
        "lord":   {"symbol": "𒈙", "meaning": "Mastery Pattern"},
        "city":   {"symbol": "𒐫", "meaning": "Domain / Context"},
        "separator": {"symbol": "꧄", "meaning": "Catalytic Split"},
        "union": {"symbol": "꧃", "meaning": "Integrated Return"}
    },
    "processFlow": [
        {"step": 1, "state": "INITIALIZE", "description": "Define origin, action, mastery, domain."},
        {"step": 2, "state": "ITERATION", "description": "Establish baseline by low-risk looping."},
        {"step": 3, "state": "SEPARATION", "description": "Catalytic split to test integrity.", "symbol": "꧄"},
        {"step": 4, "state": "UNION", "description": "Return with synthesis.", "symbol": "꧃"},
        {"step": 5, "state": "CRYSTALLIZATION", "description": "Pattern crowns the domain."}
    ],
    "operatorNotes": []
}

def _safe_dir() -> Path:
    # works in scripts and notebooks
    try:
        here = Path(__file__).parent
    except NameError:
        here = Path.cwd()
    return here

# ---------- engine ----------
class TernaryPhaseModulator:
    """
    Executable layer for the 'ternary_operator' protocol.
    """

    def __init__(
        self,
        host_name: str,
        origin: bool,
        action: bool,
        lord: bool,
        blueprint_path: str = "ternary_operator.json",
        synthesis_fn: Optional[Callable[[bool, bool, bool], bool]] = None,
        seed: Optional[int] = None,
        max_log: int = 512,
    ):
        self.host = host_name
        self.origin = bool(origin)
        self.action = bool(action)
        self.lord = bool(lord)
        self.max_log = max_log
        if seed is not None:
            random.seed(seed)

        self.protocol = self._load_blueprint(blueprint_path)
        self.logs: List[LogEntry] = []
        self.synthesis_fn = synthesis_fn or self._xor3
        self._log("Protocol initialized by host.", Level.INFO, Phase.HOST_INITIATION)

        # schema sanity
        self._validate_blueprint()

    # ----- IO -----
    def _load_blueprint(self, filename: str) -> Dict[str, Any]:
        path = _safe_dir() / filename
        if path.exists():
            try:
                with path.open("r", encoding="utf-8") as f:
                    bp = json.load(f)
                return bp
            except Exception as e:
                # fall back but report
                self._log(f"Blueprint load error '{filename}': {e}", Level.ERROR)
        # fallback
        self._log(f"Using embedded default blueprint (missing '{filename}').", Level.WARNING)
        return json.loads(json.dumps(DEFAULT_BLUEPRINT))  # deep copy

    def _validate_blueprint(self) -> None:
        required_keys = ["algorithmName", "version", "coreFormula", "processFlow", "operatorNotes"]
        missing = [k for k in required_keys if k not in self.protocol]
        if missing:
            self._log(f"Blueprint missing keys: {missing}", Level.ERROR)
            raise ValueError(f"Invalid blueprint, missing: {missing}")
        cf = self.protocol.get("coreFormula", {})
        if "syntax" not in cf or "mapping" not in cf:
            self._log("coreFormula incomplete.", Level.ERROR)
            raise ValueError("Invalid coreFormula")
        if not isinstance(self.protocol["operatorNotes"], list):
            self._log("operatorNotes must be a list.", Level.ERROR)
            self.protocol["operatorNotes"] = []

    # ----- logging -----
    def _log(self, msg: str, level: Level = Level.INFO, phase: Optional[Phase] = None, data: Dict[str, Any] = None):
        entry = LogEntry(
            timestamp=datetime.now().isoformat(),
            host=self.host,
            level=level,
            message=msg,
            phase=phase,
            data=data or {}
        )
        self.logs.append(entry)
        # enforce ring buffer
        if len(self.logs) > self.max_log:
            self.logs = self.logs[-self.max_log:]

    # ----- operators -----
    @staticmethod
    def _xor3(a: bool, b: bool, c: bool) -> bool:
        # odd parity
        return bool(a) ^ bool(b) ^ bool(c)

    @staticmethod
    def majority3(a: bool, b: bool, c: bool) -> bool:
        return sum((bool(a), bool(b), bool(c))) >= 2

    # ----- phases -----
    def ternary_synthesis(self) -> bool:
        self._log("Executing Ternary Synthesis (a ⊕ b ⊕ c).", Phase.SEPARATION)
        return self.synthesis_fn(self.origin, self.action, self.lord)

    def recursive_integration(self, synthesis_result: bool) -> bool:
        self._log("Entering Recursive Integration (ᵠ).", Phase.UNION, data={"synthesis_result": synthesis_result})
        # model the “return to origin” as conjunction with origin, but allow operator override via mapping
        return bool(self.origin and synthesis_result)

    # ----- run -----
    def run(self) -> Dict[str, Any]:
        self._log("Process started.", Phase.HOST_INITIATION)
        self._log("Process State: INITIALIZE.", Phase.INITIALIZE, data={"origin": self.origin, "action": self.action, "lord": self.lord})
        self._log("Process State: ITERATION. Establishing baseline.", Phase.ITERATION)

        self._log("Process State: SEPARATION. Initiating integrity test.", Phase.SEPARATION)
        s = self.ternary_synthesis()
        final_truth = self.recursive_integration(s)

        if not final_truth:
            self._log("Live anomaly: Final truth is null after union.", Level.WARNING, Phase.UNION,
                      data={"origin": self.origin, "synthesis": s})
            self._log("Root cause hypothesis: disconnected 'origin' or mismatch operator.", Level.ERROR, Phase.UNION)
        else:
            self._log("Integrity check passed. Union successful.", Level.INFO, Phase.UNION)

        self._log("Process State: CRYSTALLIZATION. Finalizing mastery.", Phase.CRYSTALLIZATION)

        # merge logs into protocol copy
        protocol_out = json.loads(json.dumps(self.protocol))  # deep copy
        protocol
